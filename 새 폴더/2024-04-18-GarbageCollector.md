---
title: Garbage Collector 
date: YYYY-MM-DD HH:MM:SS +09:00
categories: [PORTPOLIO]
tags:
  [
    CS,
    Study
  ]
comments: false
math: true
mermaid: true
---

## 공부 내용

### 가비지 컬렉터

가비지 컬렉터는 자동 메모리 관리자 역할을 수행한다. 가비지 컬렉터는 메모리 할당 및 해제를 관리하며,
관리 코드를 사용하는 개발자는 메모리 관리 작업을 수행하기 위한 코드를 작성할 필요가 없다.  
  
자동 메모리 관리를 사용하면 실수로 개체 비우기를 수행하지 않거나 메모리 누수를 유발하거나 또는 이미
비워진 개체를 찾기 위해 비워진 메모리에 접근하려는 경우 등 일반적인 문제를 해결할 수 있다.

### GC의 특징

오브젝트나 배열, 문자열을 생성 및 저장하기 위해선 Heap 메모리 공간이 필요하다

메모리 공간을 할당받은 객체가 더 이상 사용되지 않으면 메모리를 회수하고, 다른
객체를 저장하는데 사용할 수 있다.

c++에서는 프로그래머가 명시적으로 힙 메모리를 할당하고 회수하는 등 수동으로 포인터 관리를 해야했다

c#에서는 가비지 컬렉터를 사용하여 자동으로 메모리를 관리한다. 가비지 컬렉터는 동적으로
할당된 메모리 중 사용하지 않는 객체를 모아 자동으로 탐지하고 해제하는 메모리 기법이다.

이는 메모리 누수와 같은 문제점을 방지하여, 프로그램의 안정성과 성능을 향상시키는데 사용된다.

c#은 이런 가비지 컬렉터를 사용해 개발자가 직접 메모리를 할당, 해제하는 번거로움을 줄어준다.

### GC 이점

1. 개발자가 수동으로 메모리를 해제할 필요가 없다.
2. 관리되는 힙에 효율적으로 개체를 할당한다.
3. 더 이상 사용되지 않는 개체를 회수하고 개체의 메모리를 해제해 이후 할당에서 이 메모리를 사용 가능하도록 한다. 관리되는 개체는 자동으로 시작을 위한 정리된 콘텐츠를 받으므로 개체의 생성자가 모든 데이터 필드를 초기화할 필요가 없다.

### GC 단점

1. 어떤 메모리를 해제할 지 결정하는 데 비용이 든다.
2. GC가 일어나는 타이밍이나 점유 시간을 미리 예측하기 힘들다.
3. 할당된 메모리가 해제되는 시점을 알 수 없다.

### C# GC 작동 방식

GC는 세대별로 나누어서 메모리를 관리한다.
즉 메모리를 3개의 세대로 나누어지고 최초의 메모리는 무조건 0이라는 공간에서 관리된다.
그리고 가비지를 한번 정리하고 해제되지 않은 객체는 다음 세대로 이동한다.

GC는 세대별 독립적으로 GC가 발생할 때 0,1,2 세대 별로 동시에 발생하는 것이 아니라 개별적으로 가비지 컬렉션을 수행한다. 또한 0세대 일수록 컬렉션이 더욱 많이 발생하게 된다.

### Unity 내 GC 작동 방식

1. Unity 실행중에 사용중인 모든 객체를 추적한다.
2. GC가 실행될 때 마다, 사용되지 않는 객체의 메모리를 찾아 해제한다.
3. 객체가 참조되는 동안 GC가 해당 객체의 메모리를 유지한다.
GC가 가비지 컬렉터를 실행할때 마다, 메모리 해체 작업이 느려질 수 있다.

### 값 타입과 레퍼런스 타입

함수 호출 시 파라미터 값이 해당 함수 호출을 위해 지정된 메모리 구역에 복사된다.

오브젝트, 문자열, 배열은 복사해야 할 바이트 값이 더 크다.
그렇기에 직접 위 값을 복사하는 것이 아닌 힙에서 할당된 스토리지 공간을 가리키는 포인터를 사용하게 된다.
따라서 함수가 호출될 때에는 포인터만 복사하면 된다.

이를 **레퍼런스 타입**이라 하며, 변수에 저장되는 값은 실제 데이터를 참조한다.

**값 타입**은 파라미터가 전달되는 동안 사본이 직접 저장되는 타입이다, int, float, bool, Unity 구조체(Color, Vector3)등이 포함된다.

### GC 최적화

1. 오브젝트 풀링
자주 사용되는 객체를 미리 생성해둔뒤, 필요할 때 다시 재사용하는 디자인 패턴으로, 
GC 사용량을 줄이고 프로그램 성능을 향상시킬 수 있습니다.

2. 리스트 크기 초기화
List를 사용 시 크기를 예상할 수 있다면, 생성자에서 초기 크기를 지정해
크기에 맞기 사용하면 요소를 추가할 때마다 메모리를 할당하지 않고, 미리 할당된 메모리에 요소를 추가한다.

3. 스트링 연산 최적화

스트링 연산은 GC를 유발하는 주요 원인 중 하나이다. 스트링을 합치는 과정에서 연산이 일어날 때마다 string 인스턴스를 생성하여 GC를 유발한다.

StringBuilder를 사용하여 이 문제를 해결할 수 있다. 
StringBuilder의 Append 함수를 사용하여 string을 추가하면 인스턴스를 생성하지 않아
GC 호출을 하지 않을 수 있다.





